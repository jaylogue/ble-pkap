/*
 *
 *    Copyright (c) 2021 Jay Logue
 *    All rights reserved.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

/**
 *   @file
 *         Utility functions for working with BLE LESC OOB paring on the
 *         Nordic nRF5 platform.
 */

#include <sdk_common.h>

#include <inttypes.h>
#include <stdio.h>

#include "nrf_crypto.h"
#include "nrf_crypto_error.h"
#include "nrf_ble_lesc.h"

#if NRF_LOG_ENABLED
#include "nrf_log.h"
#include "nrf_log_ctrl.h"
#include "nrf_log_default_backends.h"
#endif // NRF_LOG_ENABLED

#include <FunctExitUtils.h>
#include <LESCOOB.h>

namespace {

void ToHexString(uint8_t * data, size_t dataLen, char * outBuf, size_t outBufSize)
{
    for (; dataLen > 0; data++, dataLen--)
    {
        snprintf(outBuf, outBufSize, "%02" PRIx8, *data);
        if (outBufSize <= 2)
            break;
        outBuf += 2;
        outBufSize -= 2;
    }
}

}

namespace nrf5utils {

#if NRF_CRYPTO_ENABLED

static void * memreverse(void * _buf, size_t len)
{
    uint8_t * buf = (uint8_t *)_buf;
    for (size_t i = 0; i < len / 2; i++)
    {
        uint8_t tmp = buf[i];
        buf[i] = buf[len - i - 1];
        buf[len - i - 1] = tmp;
    }
    return _buf;
}

/** Compute the BLE LESC OOB confirmation value
 *
 * Computes the BLE LESC OOB confirmation value, as defined in the Bluetooth Specification
 * [Vol 3] Part H, Section 2.2.6.
 *
 * This function make use of the nrf_crypto module and requires the following build
 * options be enabled:
 *
 *      NRF_CRYPTO
 *      NRF_CRYPTO_AES
 *      NRF_CRYPTO_BACKEND_CC310_AES_CMAC or NRF_CRYPTO_BACKEND_CC310_AES_CMAC
 *
 *
 *
 * @param[in]  pkx          A 32-byte buffer containing the X-coordinate of the device's public key,
 *                          in *little* endian order.
 *
 * @param[in]  r            A 16-byte buffer containing a random value generated by the device.
 *
 * @param[in]  c            A 16-byte buffer into which the generated confirmation value will be
 *                          written.
 *
 * @returns                 NRF_SUCCESS on success, or a nRF5 SDK error code.
 *
 */
ret_code_t ComputeLESCOOBConfirmationValue(const uint8_t * pkx, const uint8_t * r, uint8_t * c)
{
    ret_code_t res;
    nrf_crypto_aes_context_t macCtx;
    uint8_t buf[kP256PubKeyCoordLength];
    size_t outSize;

    // The LESC OOB Confirmation value is computed as follows:
    //
    //    C = f4(U=PKx, V=PKx, X=r, Z=z)
    //
    // Where:
    //    PKx  - The X coordinate of the node's P-256 public key, encoded as a 32 byte
    //           string in *big* endian order.
    //    r    - A 16 byte random string generated by the node.
    //    z    - A 1-byte string identifying the pairing method being used; always 0 for OOB.
    //    f4() - The Bluetooth-defined MAC function equivalent to:
    //               AES-CMAC(key=X, value=U | V | Z)
    //
    // Note that, in the BLE protocol, and in the nRF5 API, the public key coordinates and the
    // random value (r) are sent in *little* endian order, and thus must be byte reversed for
    // the purposes of this computation.  Likewise, the resultant confirmation value is also
    // byte reversed relative to the output of the AES-CMAC function.
    //

    // Clear the output buffer.
    memset(c, 0, kBLELESCOOBConfirmLength);

    // Initialize to perform AES-CMAC with a 128-bit key
    res = nrf_crypto_aes_init(&macCtx, &g_nrf_crypto_aes_cmac_128_info, NRF_CRYPTO_MAC_CALCULATE);
    SuccessOrExit(res);

    // Set the AES-CMAC key to the reversed r value.
    memcpy(buf, r, kBLELESCOOBRandomLength);
    memreverse(buf, kBLELESCOOBRandomLength);
    res = nrf_crypto_aes_key_set(&macCtx, buf);
    SuccessOrExit(res);

    // Reverse the PKx value and feed it to the MAC function twice.
    memcpy(buf, pkx, kP256PubKeyCoordLength);
    memreverse(buf, kP256PubKeyCoordLength);
    res = nrf_crypto_aes_update(&macCtx, buf, kP256PubKeyCoordLength, c);
    SuccessOrExit(res);
    res = nrf_crypto_aes_update(&macCtx, buf, kP256PubKeyCoordLength, c);
    SuccessOrExit(res);

    // Feed the pairing method byte (0) to the MAC function and generate the final MAC value.
    outSize = kBLELESCOOBConfirmLength;
    buf[0] = 0;
    res = nrf_crypto_aes_finalize(&macCtx, buf, 1, c, &outSize);
    SuccessOrExit(res);

    VerifyOrExit(outSize == kBLELESCOOBConfirmLength, res = NRF_ERROR_DATA_SIZE);

    // Reverse the MAC value and return it to the caller as the OOB confirmation value.
    memreverse(c, kBLELESCOOBConfirmLength);

exit:
    // Clear potentially sensitive data from the stack.
    memset(&macCtx, 0, sizeof(macCtx));
    memset(buf, 0, sizeof(buf));

    return res;
}

#endif // NRF_CRYPTO_ENABLED


#if NRF_BLE_LESC_ENABLED

/** Log the local device's LESC public key value.
 */
void LogLocalLESCPublicKey(void)
{
#if NRF_LOG_ENABLED && NRF_LOG_LEVEL >= NRF_LOG_SEVERITY_INFO

    char buf[kP256PubKeyCoordLength * 2 + 1];
    ble_gap_lesc_p256_pk_t * localPubKey = nrf_ble_lesc_public_key_get();

    NRF_LOG_INFO("Local LESC public key:");
    ToHexString(localPubKey->pk, kP256PubKeyCoordLength, buf, sizeof(buf));
    NRF_LOG_INFO("  X: %s", buf);
    ToHexString(localPubKey->pk + kP256PubKeyCoordLength, kP256PubKeyCoordLength, buf, sizeof(buf));
    NRF_LOG_INFO("  Y: %s", buf);

#endif // NRF_LOG_ENABLED && NRF_LOG_LEVEL >= NRF_LOG_SEVERITY_INFO
}

/** Log the local device's LESC OOB data.
 */
void LogLocalLESCOOBData(void)
{
#if NRF_LOG_ENABLED && NRF_LOG_LEVEL >= NRF_LOG_SEVERITY_INFO

    char buf[BLE_GAP_SEC_KEY_LEN * 2 + 1];

    ble_gap_lesc_oob_data_t * localOOBData = nrf_ble_lesc_own_oob_data_get();

    NRF_LOG_INFO("Local LESC OOB data:");
    if (localOOBData != NULL)
    {
        ToHexString(localOOBData->c, BLE_GAP_SEC_KEY_LEN, buf, sizeof(buf));
        NRF_LOG_INFO("  Confirmation Value: %s", buf);
        ToHexString(localOOBData->r, BLE_GAP_SEC_KEY_LEN, buf, sizeof(buf));
        NRF_LOG_INFO("  Random Value: %s", buf);
    }
    else
    {
        NRF_LOG_INFO("  (not available)");
    }

#endif // NRF_LOG_ENABLED && NRF_LOG_LEVEL >= NRF_LOG_SEVERITY_INFO
}

#endif // NRF_BLE_LESC_ENABLED


} // namespace nrf5utils
